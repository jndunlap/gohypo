{{define "center_panel"}}
<!-- Center Panel - Research Workspace -->
<div id="center-panel" class="flex-1 flex flex-col bg-white w-full max-w-none min-w-0 transition-all duration-300 ease-in-out">
    <!-- Research Header -->
    <div class="flex-shrink-0 border-b border-gray-200 bg-gray-50 p-3 h-12">
        <div class="flex items-center justify-start gap-2">
            <h3 class="text-sm font-bold text-gray-900 uppercase tracking-wide">Research Engine</h3>
        </div>
    </div>

    <!-- Field Selection Area -->
    <div id="field-selection-area" class="flex-shrink-0 border-b border-gray-200 bg-gray-50 px-6 py-4" style="display: none;">
        <div class="flex items-center justify-between mb-3">
            <span class="text-sm font-semibold text-gray-900">Selected Fields</span>
            <button onclick="clearSelectedFields()" class="text-xs text-gray-600 hover:text-gray-900 transition-colors px-2 py-1 hover:bg-gray-200 rounded">
                Clear all
            </button>
        </div>
        <div id="selected-fields-container" class="flex flex-wrap gap-2">
            <!-- Selected field chips will appear here -->
        </div>
    </div>

    <!-- Research Content -->
    <div class="flex-1 overflow-y-auto border-r border-gray-200">
        <!-- Research Start Button - Show when datasets are available but no active research -->
        {{if and .Datasets (not .Hypotheses)}}
        <div class="dataset-block bg-white border-b border-gray-200 hover:bg-gray-50 cursor-pointer group">
            <div class="text-center py-8 px-6">
                <div class="w-10 h-10 bg-gray-200 rounded-lg flex items-center justify-center mx-auto mb-3 group-hover:bg-gray-300">
                    <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                </div>
                <p class="text-sm font-semibold text-gray-700">Start Research</p>
                <p class="text-xs text-gray-500 mt-1">Found {{len .Datasets}} dataset{{if ne (len .Datasets) 1}}s{{end}} ready for analysis</p>
                <form hx-post="/api/research/initiate"
                      hx-target="#research-status"
                      hx-swap="innerHTML"
                      class="mt-4">
                    <input type="hidden" name="workspace_id" value="{{if .WorkspaceID}}{{.WorkspaceID}}{{else}}550e8400-e29b-41d4-a716-446655440001{{end}}">
                    <button type="submit"
                            class="inline-flex items-center px-4 py-2 bg-gray-900 text-white font-mono text-sm font-medium rounded border border-gray-300 hover:bg-gray-800 transition-colors">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                        </svg>
                        Initiate
                    </button>
                </form>
                <div id="research-status" class="mt-3"></div>
            </div>
        </div>
        {{end}}

        <!-- HTMX SSE for real-time research updates -->
        <div id="sse-connection" hx-sse="connect:/api/research/sse?session_id={{.SessionID}}"
             hx-sse-swap="hypothesis_pending:#hypothesis-cards-container:beforeend"
             hx-sse-swap="progress_update:#research-progress"
             class="hidden">
        </div>

        <script>
        (function() {
            'use strict';

        // ===== SSE CONNECTION MANAGEMENT =====

        // Connection state tracking
        let sseConnectionState = {
            connected: false,
            sessionId: '{{.SessionID}}',
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            lastHeartbeat: Date.now(),
            heartbeatInterval: null
        };

        // Circuit breaker for error recovery
        let circuitBreaker = {
            failures: 0,
            lastFailureTime: 0,
            state: 'closed', // closed, open, half-open
            timeout: 60000, // 1 minute
            failureThreshold: 5
        };

        // Connection metrics for monitoring
        let connectionMetrics = {
            connectionAttempts: 0,
            successfulConnections: 0,
            failedConnections: 0,
            eventsReceived: 0,
            eventsProcessed: 0,
            lastConnectedAt: null,
            averageReconnectTime: 0
        };

        // ===== CONNECTION LIFECYCLE MANAGEMENT =====

        function startSSEHeartbeat() {
            if (sseConnectionState.heartbeatInterval) return;

            sseConnectionState.heartbeatInterval = setInterval(() => {
                const now = Date.now();
                const timeSinceLastHeartbeat = now - sseConnectionState.lastHeartbeat;

                // If no heartbeat for 30 seconds, consider connection dead
                if (timeSinceLastHeartbeat > 30000 && sseConnectionState.connected) {
                    console.warn('[SSE] Heartbeat timeout - connection may be dead');
                    handleSSEDisconnect();
                }
            }, 10000); // Check every 10 seconds
        }

        function stopSSEHeartbeat() {
            if (sseConnectionState.heartbeatInterval) {
                clearInterval(sseConnectionState.heartbeatInterval);
                sseConnectionState.heartbeatInterval = null;
            }
        }

        function handleSSEDisconnect() {
            sseConnectionState.connected = false;
            sseConnectionState.reconnectAttempts++;

            console.warn(`[SSE] Connection lost (attempt ${sseConnectionState.reconnectAttempts}/${sseConnectionState.maxReconnectAttempts})`);

            if (sseConnectionState.reconnectAttempts >= sseConnectionState.maxReconnectAttempts) {
                console.error('[SSE] Max reconnection attempts reached');
                circuitBreaker.failures++;
                circuitBreaker.lastFailureTime = Date.now();

                if (circuitBreaker.failures >= circuitBreaker.failureThreshold) {
                    circuitBreaker.state = 'open';
                    console.error('[SSE] Circuit breaker opened - SSE disabled for 1 minute');

                    setTimeout(() => {
                        circuitBreaker.state = 'half-open';
                        circuitBreaker.failures = 0;
                        console.log('[SSE] Circuit breaker half-open - attempting recovery');
                        attemptSSEReconnection();
                    }, circuitBreaker.timeout);
                }
                return;
            }

            // Exponential backoff for reconnection
            const delay = Math.min(1000 * Math.pow(2, sseConnectionState.reconnectAttempts - 1), 30000);
            setTimeout(() => {
                if (circuitBreaker.state !== 'open') {
                    attemptSSEReconnection();
                }
            }, delay);
        }

        function attemptSSEReconnection() {
            console.log('[SSE] Attempting reconnection...');
            connectionMetrics.connectionAttempts++;

            try {
                // Force HTMX to re-establish SSE connection
                const sseElement = document.getElementById('sse-connection');
                if (sseElement) {
                    // Update the connection URL with current session
                    const newUrl = `/api/research/sse?session_id=${sseConnectionState.sessionId}&reconnect=${Date.now()}`;
                    sseElement.setAttribute('hx-sse', 'connect:' + newUrl);

                    // Trigger reconnection
                    htmx.process(sseElement);

                    // Set timeout for connection success
                    setTimeout(() => {
                        if (!sseConnectionState.connected) {
                            connectionMetrics.failedConnections++;
                            handleSSEDisconnect();
                        }
                    }, 5000);
                }
            } catch (error) {
                console.error('[SSE] Reconnection failed:', error);
                connectionMetrics.failedConnections++;
                handleSSEDisconnect();
            }
        }

        function handleSSEConnect() {
            sseConnectionState.connected = true;
            sseConnectionState.reconnectAttempts = 0;
            sseConnectionState.lastHeartbeat = Date.now();
            connectionMetrics.successfulConnections++;
            connectionMetrics.lastConnectedAt = Date.now();

            if (circuitBreaker.state === 'half-open') {
                circuitBreaker.state = 'closed';
                console.log('[SSE] Circuit breaker closed - connection recovered');
            }

            console.log('[SSE] Connection established successfully');
            startSSEHeartbeat();
        }

        // ===== SESSION MANAGEMENT =====

        function updateSessionContext(newSessionId) {
            if (sseConnectionState.sessionId !== newSessionId) {
                console.log(`[SSE] Session changed: ${sseConnectionState.sessionId} â†’ ${newSessionId}`);
                sseConnectionState.sessionId = newSessionId;

                // Reconnect with new session
                if (sseConnectionState.connected) {
                    handleSSEDisconnect();
                } else {
                    attemptSSEReconnection();
                }
            }
        }

        // ===== EVENT HANDLING =====

        // HTMX SSE event listeners
        document.addEventListener('htmx:sseBeforeMessage', function(evt) {
            connectionMetrics.eventsReceived++;

            const event = evt.detail;
            sseConnectionState.lastHeartbeat = Date.now();

            // Validate event belongs to current session
            if (event.data && event.data.session_id && event.data.session_id !== sseConnectionState.sessionId) {
                console.warn(`[SSE] Ignoring event for different session: ${event.data.session_id}`);
                evt.preventDefault();
                return;
            }

            // Add event timestamp for staleness detection
            event.receivedAt = Date.now();

            console.log('[SSE] Received event:', event.event, 'for session:', sseConnectionState.sessionId);
        });

        document.addEventListener('htmx:sseAfterMessage', function(evt) {
            connectionMetrics.eventsProcessed++;

            const event = evt.detail;
            console.log('[SSE] Processed event:', event.event);

            // Handle connection established
            if (event.event === 'sse:connected' || event.event === 'connect') {
                handleSSEConnect();
            }

            // Handle specific events
            if (event.event === 'referee_completed') {
                console.log('[SSE] Referee completed, triggering hypothesis reload...');
                const trigger = document.getElementById('hypothesis-reload-trigger');
                if (trigger) {
                    htmx.trigger(trigger, 'click');
                }
            }

            // Also trigger immediate refresh on any SSE event during research
            if (event.event === 'referee_completed' || event.event === 'progress_update') {
                const container = document.getElementById('hypothesis-cards-container');
                if (container && container.children.length > 0) {
                    console.log('[SSE] Triggering immediate hypothesis refresh');
                    fetch('/api/research/ledger?limit=50', {
                        headers: {
                            'HX-Request': 'true'
                        }
                    })
                        .then(response => response.text())
                        .then(html => {
                            container.innerHTML = html;
                        })
                        .catch(error => {
                            console.error('[SSE] Failed to refresh hypotheses:', error);
                        });
                }
            }
        });

        document.addEventListener('htmx:sseError', function(evt) {
            console.error('[SSE] SSE Error:', evt.detail);
            circuitBreaker.failures++;
            circuitBreaker.lastFailureTime = Date.now();

            connectionMetrics.failedConnections++;
            handleSSEDisconnect();
        });

        document.addEventListener('htmx:sseClose', function(evt) {
            console.warn('[SSE] Connection closed');
            sseConnectionState.connected = false;
            stopSSEHeartbeat();

            if (circuitBreaker.state !== 'open') {
                setTimeout(() => handleSSEDisconnect(), 1000);
            }
        });

        // Periodic refresh of hypotheses during active research
        let hypothesisRefreshInterval = null;

        function startHypothesisRefresh() {
            if (hypothesisRefreshInterval) return; // Already running

            console.log('[UI] Starting periodic hypothesis refresh');
            hypothesisRefreshInterval = setInterval(function() {
                // Only refresh if we have hypotheses and are in an active research state
                const container = document.getElementById('hypothesis-cards-container');
                if (container && container.children.length > 0) {
                    console.log('[UI] Periodic hypothesis refresh');
                    fetch('/api/research/ledger?limit=50', {
                        headers: {
                            'HX-Request': 'true'
                        }
                    })
                        .then(response => response.text())
                        .then(html => {
                            container.innerHTML = html;
                        })
                        .catch(error => {
                            console.error('[UI] Failed to refresh hypotheses:', error);
                        });
                }
            }, 2000); // Refresh every 2 seconds
        }

        function stopHypothesisRefresh() {
            if (hypothesisRefreshInterval) {
                console.log('[UI] Stopping periodic hypothesis refresh');
                clearInterval(hypothesisRefreshInterval);
                hypothesisRefreshInterval = null;
            }
        }


        // ===== INITIALIZATION =====

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Research center panel initialized');

            // Start SSE heartbeat monitoring
            startSSEHeartbeat();

            // Start periodic refresh if we have hypotheses (active research)
            const container = document.getElementById('hypothesis-cards-container');
            if (container && container.children.length > 0) {
                startHypothesisRefresh();
                // Stop refresh after 2 minutes (research should be done by then)
                setTimeout(stopHypothesisRefresh, 120000);
            }

            // Log initial connection metrics
            console.log('[SSE] Initial connection state:', sseConnectionState);
        });

        // ===== GLOBAL EXPORTS =====
        window.SSEManager = {
            updateSessionContext: updateSessionContext,
            getConnectionState: () => sseConnectionState,
            getCircuitBreakerState: () => circuitBreaker,
            getConnectionMetrics: () => connectionMetrics,
            forceReconnect: attemptSSEReconnection
        };
        })();
        </script>

        <!-- Hypothesis Cards Container -->
        <div id="hypothesis-cards-container" class="divide-y divide-gray-100">
            {{if .Hypotheses}}
                {{template "hypothesis_list_compact" .}}
            {{else}}
                <div class="text-center py-12 px-6">
                    <div class="w-10 h-10 bg-gray-200 rounded-lg flex items-center justify-center mx-auto mb-3">
                        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                        </svg>
                    </div>
                    <p class="text-sm font-semibold text-gray-700">No Research Hypotheses Yet</p>
                    <p class="text-xs text-gray-500 mt-1">Start research to generate hypothesis cards</p>
                </div>
            {{end}}
        </div>

        <!-- Rejected Hypotheses Section - Hidden by default, shown when hypothesis selected -->
        <div id="rejected-hypotheses-section" class="px-6 pb-6" style="display: none;">
            <div class="border-t border-gray-200 pt-6">
                <h3 class="text-sm font-bold text-gray-900 uppercase tracking-wide mb-4">Rejected Hypotheses</h3>
                <div id="rejected-hypotheses-container" class="space-y-0">
                    <div class="text-center py-12 px-6 text-gray-500 bg-white border-t border-gray-200">
                        <div class="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center mx-auto mb-2">
                            <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <div class="text-sm font-semibold text-gray-700">No rejected hypotheses</div>
                        <div class="text-xs mt-1 text-gray-500">Failed validations will appear here</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- HTMX SSE for real-time event display -->
    <div id="research-events" hx-sse="connect:/api/research/sse"
         hx-sse-swap="research_event:#sse-events"
         class="hidden">
                </div>
</div>
{{end}}
